Цель: реализовать управление центром роя, чтобы при его движении за ним соответствующим образом двигался и рой. 
Продвинутый уровень: рои будут пытаться убежать от врагов, цель игрока - сохранить как можно больше чуваков. Вспоследствии можно реализовать лабиринты, препятствия и т.д.
Вариант: вожак будет пытаться удрать сам от себя как от центра кластера.

tfin - количество временных тактов
w - длина и ширина рабочей области (пока считаем, что он квадратный)
r - радиус точки
x = (np.array[1, 1, 1], np.array[1, 0, 0]) - массив историй перемещения каждого элемента. Задали начальное положение чуваков (пока что все отрисовано в двумерной с.к.).
Соответствующие столбцы - координаты x, y, z.
x[k][i] - текущая координата i-го чувака, v[k][i] - текущая скорость i-го чувака
Пока что новые чуваки добавляются вручную путём добавления новой координаты и новых параметров в скорость.
xc - координата центра кластера
col1 - цвет фона
col2 - цвет сопутствующих чуваков
col3 - цвет лидера
alpha - из метода роя (подбирается вручную)
В цикле потактно реализована система уравнений с семинара.
Сначала всё отрисовываем, потом засовываем в гифку.

В данный момент после того, как чуваки достигают края экрана, они прыгают на противоположную границу (как в змейке).
Чтобы чуваки шатались не по одной прямой, альфа должны быть не константами.
Потом может пригодиться RGBA и прозрачность, потому что при большом кол-ве чуваков всё перемешается и сложно будет выделить центр кластера.

Нарисовали границы рабочей области.
Движение вожака вынесли за цикл.

draw.rectangle((0,0,w-1,w-1),fill=col1,outline=col2) #размеры коробки меньше размеров экрана на 1
#...> w-1-r и ... <r - чтобы чуваки не втыкались носом в границу
if(((x[k][-1]+alpha[k][0]*v[k][-1])[0]>w-1-r) or ((x[k][-1]+alpha[k][0]*v[k][-1])[0]<r)):
      v[k][-1][0]=-v[k][-1][0] #при столкновении меняется на противоположную соответствующая компонента скорости (работает для всех трёх измерений

